<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Star and Planet Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #000;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }
        canvas {
            display: block;
            background-color: #000;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
            width: 100vw;
            height: 100vh;
        }
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
            text-align: center;
            z-index: 1000;
            display: none;
        }
        .message-box button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 15px;
            font-size: 1em;
        }
        .message-box button:hover {
            background-color: #45a049;
        }
        .focus-release-button {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 40px;
            height: 40px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 24px;
            color: #fff;
            font-weight: bold;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.1);
            z-index: 10;
            transition: background-color 0.3s ease;
            display: none;
        }
        .focus-release-button:hover {
            background-color: rgba(255, 255, 255, 0.4);
        }
        .control-button {
            position: absolute;
            bottom: 10px;
            width: 40px;
            height: 40px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.1);
            z-index: 10;
            transition: background-color 0.3s ease, transform 0.2s ease;
            font-size: 20px;
        }
        .control-button:hover {
            background-color: rgba(0, 0, 0, 0.9);
            transform: scale(1.1);
        }
        .control-button[title]:hover:after {
            content: attr(title);
            position: absolute;
            bottom: 50px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 100;
        }
        #toggleFieldLinesButton {
            left: 10px;
        }
        #toggleSpaceshipButton {
            left: 60px;
        }
        #toggleGravityFieldButton {
            left: 110px;
        }
        #togglePauseButton {
            left: 160px;
        }
        .planet-button {
            left: calc(210px + (var(--button-index) * 50px));
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            font-size: 0;
        }
        .info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            display: none;
            z-index: 10;
            font-size: 14px;
        }
        .help-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            z-index: 1000;
            display: none;
            color: #fff;
            font-size: 16px;
            max-width: 400px;
        }
        .help-overlay h2 {
            margin-top: 0;
        }
        .help-overlay ul {
            list-style: none;
            padding: 0;
        }
        .help-overlay li {
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div id="messageBox" class="message-box">
        <p id="messageText"></p>
        <button onclick="hideMessageBox()">OK</button>
    </div>
    <div id="focusReleaseButton" class="focus-release-button">
        &times;
    </div>
    <div id="toggleFieldLinesButton" class="control-button" title="Toggle Magnetic Field Lines">
        üß≤
    </div>
    <div id="toggleSpaceshipButton" class="control-button" title="Toggle Spaceship Mode">
        üöÄ
    </div>
    <div id="toggleGravityFieldButton" class="control-button" title="Toggle Gravity Field">
        üí´
    </div>
    <div id="togglePauseButton" class="control-button" title="Pause/Resume Simulation">
        ‚èØÔ∏è
    </div>
    <div id="planetButton0" class="control-button planet-button"></div>
    <div id="planetButton1" class="control-button planet-button"></div>
    <div id="planetButton2" class="control-button planet-button"></div>
    <div id="planetButton3" class="control-button planet-button"></div>
    <div id="planetButton4" class="control-button planet-button"></div>
    <div id="planetButton5" class="control-button planet-button"></div>
    <div id="planetButton6" class="control-button planet-button"></div>
    <div id="planetButton7" class="control-button planet-button"></div>
    <div id="planetButton8" class="control-button planet-button"></div>
    <div id="planetButtonSystem" class="control-button planet-button"></div>
    <div id="infoPanel" class="info-panel"></div>
    <div id="helpOverlay" class="help-overlay">
        <h2>Controls</h2>
        <ul>
            <li><b>0</b>: Focus on Sun</li>
            <li><b>1-9</b>: Focus on planets</li>
            <li><b>Mouse Drag</b>: Orbit camera (orbit mode)</li>
            <li><b>Mouse Wheel</b>: Zoom in/out</li>
            <li><b>WASD</b>: Move spaceship (spaceship mode)</li>
            <li><b>H</b>: Toggle this help</li>
        </ul>
        <button onclick="toggleHelpOverlay()">Close</button>
    </div>

    <script>
        // --- Configuration Constants ---
        const Config = {
            CAMERA: {
                FOV: 75,
                NEAR: 0.1,
                FAR: 2000,
                ORBIT_RADIUS_DEFAULT: 70,
                ORBIT_RADIUS_MIN: 5,
                ORBIT_RADIUS_MAX: 400,
                ORBIT_ROTATION_SPEED: 0.005,
                ORBIT_ZOOM_SPEED: 0.1,
                PLANET_ZOOM_MULTIPLIER: 8,
                ANIMATION_LERP_FACTOR: 0.05,
                ANIMATION_THRESHOLD_RADIUS: 0.1,
                ANIMATION_THRESHOLD_ANGLE: 0.001
            },
            STAR: {
                RADIUS: 5,
                COLOR: 0xFFFF00,
                LIGHT_INTENSITY: 2.0,
                LIGHT_DISTANCE: 100,
                ROTATION_SPEED: 0.001,
                FIELD_LINES: {
                    NUM_LINES: 50,
                    EXTENT_EQUATORIAL: 20,
                    COLOR: 0xFFD700
                },
                VISUAL_MASS: 1000
            },
            PLANETS: [
                { name: "Mercury", radius: 0.5, color: 0x8A8A8A, orbit: 10, orbitSpeed: 0.02, texture: "https://placehold.co/256x256/8A8A8A/FFFFFF?text=Mercury", fieldLines: { numLines: 5, extent: 2, color: 0x808080 }, visualMass: 10 },
                { name: "Venus", radius: 0.9, color: 0xFFD700, orbit: 18, orbitSpeed: 0.015, texture: "https://placehold.co/256x256/FFD700/000000?text=Venus", fieldLines: { numLines: 5, extent: 2, color: 0xFF8C00 }, visualMass: 50 },
                { name: "Earth", radius: 1.0, color: 0x0000FF, orbit: 25, orbitSpeed: 0.01, texture: "https://cdn.jsdelivr.net/gh/mrdoob/three.js@dev/examples/textures/planets/earth_atmos_2048.jpg", lightsTexture: "https://cdn.jsdelivr.net/gh/mrdoob/three.js@dev/examples/textures/planets/earth_lights_2048.png", moons: [{ radius: 0.2, color: 0xCCCCCC, orbit: 2.5, orbitSpeed: 0.05 }], fieldLines: { numLines: 30, extent: 8, color: 0x00FF00 }, visualMass: 60 },
                { name: "Mars", radius: 0.7, color: 0xFF4500, orbit: 32, orbitSpeed: 0.009, texture: "https://placehold.co/256x256/FF4500/FFFFFF?text=Mars", moons: [{ radius: 0.1, color: 0x663300, orbit: 1.0, orbitSpeed: 0.08 }, { radius: 0.08, color: 0x663300, orbit: 1.5, orbitSpeed: 0.06 }], fieldLines: { numLines: 5, extent: 3, color: 0xFF4500 }, visualMass: 20 },
                { name: "Jupiter", radius: 3.5, color: 0xF4A460, orbit: 45, orbitSpeed: 0.006, texture: "https://placehold.co/256x256/F4A460/000000?text=Jupiter", moons: [{ radius: 0.5, color: 0xFFD700, orbit: 5.0, orbitSpeed: 0.04 }, { radius: 0.4, color: 0xADD8E6, orbit: 6.5, orbitSpeed: 0.035 }, { radius: 0.6, color: 0x8B4513, orbit: 8.0, orbitSpeed: 0.03 }, { radius: 0.55, color: 0x696969, orbit: 9.5, orbitSpeed: 0.025 }], fieldLines: { numLines: 40, extent: 15, color: 0xFFFFFF }, visualMass: 800 },
                { name: "Saturn", radius: 3.0, color: 0xDAA520, orbit: 60, orbitSpeed: 0.004, texture: "https://placehold.co/256x256/DAA520/000000?text=Saturn", rings: { innerRadius: 4.0, outerRadius: 7.0, color: 0x8B4513, opacity: 0.7 }, fieldLines: { numLines: 35, extent: 12, color: 0xFFFFFF }, visualMass: 600 },
                { name: "Uranus", radius: 2.0, color: 0xAFEEEE, orbit: 75, orbitSpeed: 0.0025, texture: "https://placehold.co/256x256/AFEEEE/000000?text=Uranus", fieldLines: { numLines: 25, extent: 10, color: 0xADD8E6 }, visualMass: 200 },
                { name: "Neptune", radius: 2.0, color: 0x4169E1, orbit: 90, orbitSpeed: 0.002, texture: "https://placehold.co/256x256/4169E1/FFFFFF?text=Neptune", rings: { innerRadius: 2.5, outerRadius: 3.5, color: 0xADD8E6, opacity: 0.9 }, fieldLines: { numLines: 25, extent: 10, color: 0x4169E1 }, visualMass: 220 },
                { name: "Pluto", radius: 0.3, color: 0xCD853F, orbit: 105, orbitSpeed: 0.001, texture: "https://placehold.co/256x256/CD853F/FFFFFF?text=Pluto", fieldLines: { numLines: 2, extent: 1.5, color: 0xCD853F }, visualMass: 5 }
            ],
            ASTEROID_BELT: {
                INNER_RADIUS: 35,
                OUTER_RADIUS: 42,
                NUM_ASTEROIDS: 500,
                ASTEROID_RADIUS: 0.1,
                COLOR: 0x8B4513,
                ORBIT_SPEED_MIN: 0.001,
                ORBIT_SPEED_MAX: 0.002,
                ROTATION_SPEED_MIN: 0.005,
                ROTATION_SPEED_MAX: 0.02
            },
            STARS: {
                COUNT: 1000,
                RADIUS: 0.2,
                COLOR: 0xFFFFFF,
                MAX_DISTANCE: 1500,
                NEBULA_AVOID_RADIUS: 700
            },
            NEBULA: {
                SPHEROID_COUNT: 30000,
                OUTER_RADIUS: 700,
                INNER_RADIUS: 200,
                CLUSTER_INFLUENCE: 0.3,
                COLOR_PALETTE: [
                    0xFF00FF,
                    0x8000FF,
                    0xCC00CC,
                    0x660099
                ],
                SPHEROID_SIZE_MIN: 2,
                SPHEROID_SIZE_MAX: 10,
                OPACITY_MIN: 0.0001,
                OPACITY_MAX: 0.0051,
                ROTATION_SPEED_Y: 0.0005,
                ROTATION_SPEED_X: 0.0002
            },
            SPACESHIP: {
                SPEED: 0.5,
                ROTATION_SPEED: 0.005,
                CAMERA_OFFSET: new THREE.Vector3(0, 5, -20)
            },
            GRAVITY_FIELD: {
                GRID_SIZE: 600,
                GRID_SPACING: 1,
                STATIC_GRID_RENDER_INTERVAL: 13,
                STATIC_PARTICLE_SIZE: 0.1,
                STATIC_PARTICLE_OPACITY: 0.2,
                STATIC_PARTICLE_COLOR: 0x00FFFF,
                FALLING_PARTICLE_COUNT: 50000,
                FALLING_PARTICLE_SIZE: 0.4,
                FALLING_PARTICLE_OPACITY: 0.8,
                FALLING_PARTICLE_COLOR_START: 0x00FFFF,
                FALLING_PARTICLE_COLOR_END: 0xFF0000,
                FALLING_PARTICLE_MIN_LIFETIME: 300,
                FALLING_PARTICLE_MAX_LIFETIME: 600,
                GRAVITY_STRENGTH: 0.005,
                VELOCITY_DECAY: 0.99,
                RESET_THRESHOLD_RADIUS_MULTIPLIER: 1.5,
                MAX_PARTICLE_DISPLACEMENT: 200,
                COLOR_CHANGE_DISTANCE_FACTOR: 50,
                FADE_DURATION: 500
            },
            UI: {
                BUTTON_ICON_SIZE: 40,
                PLANET_BUTTON_START_INDEX: 4
            }
        };

        // Global variables
        let scene, camera, renderer;
        let star;
        const planets = [];
        const moons = [];
        const asteroids = [];
        let nebulaGroup;
        const planetFieldLines = [];
        let staticGridParticles;
        let fallingGravityParticles;
        let gravityFieldVisible = false;
        let gravityFadeOpacity = 0;
        const staticGridPositions = [];
        const fallingParticlesData = [];
        let orbitRadius = Config.CAMERA.ORBIT_RADIUS_DEFAULT;
        let orbitTheta = 0;
        let orbitPhi = Math.PI / 2;
        let currentCameraTarget;
        let isAnimatingCamera = false;
        let targetOrbitRadius, targetOrbitTheta, targetOrbitPhi;
        let cameraMode = 'orbit';
        let spaceship;
        const keyboardState = { w: false, s: false, a: false, d: false };
        let isSteering = false;
        let mouseLookX = 0;
        let mouseLookY = 0;
        let isDragging = false;
        let previousMouseX = 0;
        let previousMouseY = 0;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let hoveredPlanet = null;
        let isPaused = false;
        const tempVector = new THREE.Vector3();
        const tempForce = new THREE.Vector3();
        const tempColor = new THREE.Color();
        const colorStart = new THREE.Color(Config.GRAVITY_FIELD.FALLING_PARTICLE_COLOR_START);
        const colorEnd = new THREE.Color(Config.GRAVITY_FIELD.FALLING_PARTICLE_COLOR_END);
        const focusReleaseButton = document.getElementById('focusReleaseButton');
        const toggleFieldLinesButton = document.getElementById('toggleFieldLinesButton');
        const toggleSpaceshipButton = document.getElementById('toggleSpaceshipButton');
        const toggleGravityFieldButton = document.getElementById('toggleGravityFieldButton');
        const togglePauseButton = document.getElementById('togglePauseButton');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const infoPanel = document.getElementById('infoPanel');
        const helpOverlay = document.getElementById('helpOverlay');
        const textureLoader = new THREE.TextureLoader();
        let touchStartX = 0;
        let touchStartY = 0;

        function showMessageBox(message) {
            messageText.textContent = message;
            messageBox.style.display = 'block';
        }

        function hideMessageBox() {
            messageBox.style.display = 'none';
        }

        function toggleHelpOverlay() {
            helpOverlay.style.display = helpOverlay.style.display === 'block' ? 'none' : 'block';
        }

        function cartesianToSpherical(x, y, z) {
            const radius = Math.sqrt(x * x + y * y + z * z);
            const theta = Math.atan2(x, z);
            const phi = Math.acos(y / radius);
            return { radius, theta, phi };
        }

        function setupScene() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(Config.CAMERA.FOV, window.innerWidth / window.innerHeight, Config.CAMERA.NEAR, Config.CAMERA.FAR);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            window.addEventListener('resize', onWindowResize, false);
        }

        function createSun() {
            const starGeometry = new THREE.SphereGeometry(Config.STAR.RADIUS, 32, 32);
            const starMaterial = new THREE.MeshBasicMaterial({ color: Config.STAR.COLOR });
            star = new THREE.Mesh(starGeometry, starMaterial);
            scene.add(star);
            currentCameraTarget = star;
            const pointLight = new THREE.PointLight(0xFFFFFF, Config.STAR.LIGHT_INTENSITY, Config.STAR.LIGHT_DISTANCE);
            star.add(pointLight);
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
        }

        function createPlanet(planetConfig) {
            const lod = new THREE.LOD();
            const levels = [
                { distance: 50, geometry: new THREE.SphereGeometry(planetConfig.radius, 32, 32) },
                { distance: 100, geometry: new THREE.SphereGeometry(planetConfig.radius, 16, 16) },
                { distance: 200, geometry: new THREE.SphereGeometry(planetConfig.radius, 8, 8) }
            ];
            let planetMaterial;
            if (planetConfig.texture) {
                planetMaterial = new THREE.MeshPhongMaterial({ color: planetConfig.color, emissive: 0x000000, specular: 0x111111, shininess: 30 });
                textureLoader.load(planetConfig.texture,
                    (texture) => { planetMaterial.map = texture; planetMaterial.needsUpdate = true; },
                    undefined,
                    () => {
                        console.warn(`Failed to load texture for ${planetConfig.name}, using fallback color`);
                        planetMaterial.map = null;
                    }
                );
            } else {
                planetMaterial = new THREE.MeshPhongMaterial({ color: planetConfig.color, emissive: 0x000000, specular: 0x111111, shininess: 30 });
            }
            levels.forEach(level => {
                const mesh = new THREE.Mesh(level.geometry, planetMaterial);
                lod.addLevel(mesh, level.distance);
            });
            lod.name = planetConfig.name;
            lod.userData.originalEmissiveColor = planetMaterial.emissive.getHex();
            const orbitPivot = new THREE.Object3D();
            star.add(orbitPivot);
            lod.position.x = planetConfig.orbit;
            orbitPivot.add(lod);
            const planetData = {
                mesh: lod,
                orbitPivot: orbitPivot,
                orbitSpeed: planetConfig.orbitSpeed,
                rotationSpeed: Math.random() * 0.02 + 0.005,
                name: planetConfig.name,
                visualMass: planetConfig.visualMass
            };
            planets.push(planetData);
            return planetData;
        }

        function addEarthLights(earthMesh, earthRadius, lightsTextureUrl) {
            const lightsGeometry = new THREE.SphereGeometry(earthRadius + 0.005, 32, 32);
            const lightsMaterial = new THREE.MeshBasicMaterial({
                map: textureLoader.load(lightsTextureUrl, undefined, undefined, () => { console.warn('Failed to load Earth lights texture'); }),
                transparent: true,
                blending: THREE.AdditiveBlending,
                opacity: 0.8
            });
            const lightsMesh = new THREE.Mesh(lightsGeometry, lightsMaterial);
            earthMesh.addLevel(lightsMesh, 50);
        }

        function createMoon(parentPlanetMesh, moonConfig) {
            const moonGeometry = new THREE.SphereGeometry(moonConfig.radius, 16, 16);
            const moonMaterial = new THREE.MeshLambertMaterial({ color: moonConfig.color });
            const moon = new THREE.Mesh(moonGeometry, moonMaterial);
            const moonOrbitPivot = new THREE.Object3D();
            parentPlanetMesh.add(moonOrbitPivot);
            moon.position.x = moonConfig.orbit;
            moonOrbitPivot.add(moon);
            moons.push({
                mesh: moon,
                orbitPivot: moonOrbitPivot,
                orbitSpeed: moonConfig.orbitSpeed,
                rotationSpeed: Math.random() * 0.05 + 0.01
            });
        }

        function createRing(planetMesh, ringConfig) {
            const ringGeometry = new THREE.RingGeometry(ringConfig.innerRadius, ringConfig.outerRadius, 64);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: ringConfig.color,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: ringConfig.opacity,
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = Math.PI / 2;
            planetMesh.addLevel(ring, 50);
        }

        function createAsteroidBelt() {
            const { INNER_RADIUS, OUTER_RADIUS, NUM_ASTEROIDS, ASTEROID_RADIUS, COLOR, ORBIT_SPEED_MIN, ORBIT_SPEED_MAX, ROTATION_SPEED_MIN, ROTATION_SPEED_MAX } = Config.ASTEROID_BELT;
            const geometry = new THREE.SphereGeometry(ASTEROID_RADIUS, 8, 8);
            const material = new THREE.MeshLambertMaterial({ color: COLOR });
            const instancedMesh = new THREE.InstancedMesh(geometry, material, NUM_ASTEROIDS);
            const matrix = new THREE.Matrix4();
            for (let i = 0; i < NUM_ASTEROIDS; i++) {
                const radius = INNER_RADIUS + Math.random() * (OUTER_RADIUS - INNER_RADIUS);
                const angle = Math.random() * Math.PI * 2;
                const y = (Math.random() - 0.5) * 2;
                matrix.setPosition(radius * Math.cos(angle), y, radius * Math.sin(angle));
                instancedMesh.setMatrixAt(i, matrix);
                asteroids.push({
                    index: i,
                    orbitRadius: radius,
                    orbitSpeed: (Math.random() * (ORBIT_SPEED_MAX - ORBIT_SPEED_MIN)) + ORBIT_SPEED_MIN,
                    angle: angle,
                    rotationSpeed: (Math.random() * (ROTATION_SPEED_MAX - ROTATION_SPEED_MIN)) + ROTATION_SPEED_MIN
                });
            }
            scene.add(instancedMesh);
            asteroids.instancedMesh = instancedMesh;
        }

        function createStars() {
            const { COUNT, RADIUS, COLOR, MAX_DISTANCE, NEBULA_AVOID_RADIUS } = Config.STARS;
            const geometry = new THREE.SphereGeometry(RADIUS, 8, 8);
            const material = new THREE.MeshBasicMaterial({ color: COLOR });
            const instancedMesh = new THREE.InstancedMesh(geometry, material, COUNT);
            const matrix = new THREE.Matrix4();
            let i = 0;
            while (i < COUNT) {
                const x = (Math.random() * 2 - 1) * MAX_DISTANCE;
                const y = (Math.random() * 2 - 1) * MAX_DISTANCE;
                const z = (Math.random() * 2 - 1) * MAX_DISTANCE;
                if (new THREE.Vector3(x, y, z).length() > NEBULA_AVOID_RADIUS) {
                    matrix.setPosition(x, y, z);
                    instancedMesh.setMatrixAt(i, matrix);
                    i++;
                }
            }
            scene.add(instancedMesh);
        }

        function createOrganicNebula() {
            const { SPHEROID_COUNT, OUTER_RADIUS, INNER_RADIUS, CLUSTER_INFLUENCE, COLOR_PALETTE, SPHEROID_SIZE_MIN, SPHEROID_SIZE_MAX, OPACITY_MIN, OPACITY_MAX } = Config.NEBULA;
            nebulaGroup = new THREE.Group();
            scene.add(nebulaGroup);
            const clusterColors = COLOR_PALETTE.map(c => new THREE.Color(c));
            const nebulaClusterCenters = [
                { position: new THREE.Vector3(300, 100, 200), color: clusterColors[0] },
                { position: new THREE.Vector3(-250, -150, -300), color: clusterColors[1] },
                { position: new THREE.Vector3(0, 300, -100), color: clusterColors[0] },
                { position: new THREE.Vector3(150, -200, 350), color: clusterColors[1] },
                { position: new THREE.Vector3(-350, 50, -50), color: clusterColors[0] },
                { position: new THREE.Vector3(200, -250, -100), color: clusterColors[1] },
                { position: new THREE.Vector3(-100, 180, 250), color: clusterColors[2] },
                { position: new THREE.Vector3(250, 50, -250), color: clusterColors[3] },
                { position: new THREE.Vector3(-150, -100, 150), color: clusterColors[2] },
                { position: new THREE.Vector3(100, -50, -200), color: clusterColors[3] }
            ];
            const baseSpheroidGeometry = new THREE.SphereGeometry(1, 8, 8);
            for (let i = 0; i < SPHEROID_COUNT; i++) {
                let randomRadius = INNER_RADIUS + Math.random() * (OUTER_RADIUS - INNER_RADIUS);
                let randomPhi = Math.acos(2 * Math.random() - 1);
                let randomTheta = Math.random() * Math.PI * 2;
                let particlePosition = new THREE.Vector3(randomRadius * Math.sin(randomPhi) * Math.cos(randomTheta),
                                                         randomRadius * Math.cos(randomPhi),
                                                         randomRadius * Math.sin(randomPhi) * Math.sin(randomTheta));
                const clusterSeed = nebulaClusterCenters[Math.floor(Math.random() * nebulaClusterCenters.length)];
                particlePosition.lerp(clusterSeed.position, CLUSTER_INFLUENCE);
                const distanceToOrigin = particlePosition.length();
                if (distanceToOrigin < INNER_RADIUS || distanceToOrigin > OUTER_RADIUS) {
                    randomRadius = INNER_RADIUS + Math.random() * (OUTER_RADIUS - INNER_RADIUS);
                    randomPhi = Math.acos(2 * Math.random() - 1);
                    randomTheta = Math.random() * Math.PI * 2;
                    particlePosition.set(randomRadius * Math.sin(randomPhi) * Math.cos(randomTheta),
                                         randomRadius * Math.cos(randomPhi),
                                         randomRadius * Math.sin(randomPhi) * Math.sin(randomTheta));
                }
                const spheroidRadius = Math.random() * (SPHEROID_SIZE_MAX - SPHEROID_SIZE_MIN) + SPHEROID_SIZE_MIN;
                const spheroidMaterial = new THREE.MeshBasicMaterial({
                    color: clusterSeed.color,
                    transparent: true,
                    opacity: Math.random() * (OPACITY_MAX - OPACITY_MIN) + OPACITY_MIN,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                const spheroid = new THREE.Mesh(baseSpheroidGeometry, spheroidMaterial);
                spheroid.position.copy(particlePosition);
                spheroid.scale.set(spheroidRadius, spheroidRadius, spheroidRadius);
                nebulaGroup.add(spheroid);
            }
        }

        function createMagneticFieldLines(celestialBodyMesh, bodyRadius, numLines, fieldExtentEquatorial, lineColor) {
            const fieldLinesGroup = new THREE.Group();
            fieldLinesGroup.visible = false;
            const lineSegments = 100;
            const lineMaterial = new THREE.LineBasicMaterial({
                color: lineColor,
                transparent: true,
                opacity: 0.6
            });
            for (let i = 0; i < numLines; i++) {
                const initialRadius = bodyRadius * 1.05;
                const initialPhi = Math.PI * Math.random() * 0.45;
                const initialTheta = Math.random() * Math.PI * 2;
                let r_equatorial = initialRadius / (Math.sin(initialPhi) * Math.sin(initialPhi));
                const actualREquatorial = Math.min(r_equatorial, fieldExtentEquatorial);
                const points = [];
                const phiStep = (Math.PI - 2 * initialPhi) / lineSegments;
                for (let j = 0; j <= lineSegments; j++) {
                    const currentPhiPolar = initialPhi + j * phiStep;
                    const r = actualREquatorial * Math.sin(currentPhiPolar) * Math.sin(currentPhiPolar);
                    if (r < bodyRadius * 0.95) {
                        break;
                    }
                    const x = r * Math.sin(currentPhiPolar) * Math.cos(initialTheta);
                    const y = r * Math.cos(currentPhiPolar);
                    const z = r * Math.sin(currentPhiPolar) * Math.sin(initialTheta);
                    points.push(new THREE.Vector3(x, y, z));
                }
                if (points.length > 5) {
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(geometry, lineMaterial);
                    fieldLinesGroup.add(line);
                }
            }
            celestialBodyMesh.add(fieldLinesGroup);
            planetFieldLines.push(fieldLinesGroup);
        }

        function toggleMagneticFieldLines() {
            planetFieldLines.forEach(group => {
                group.visible = !group.visible;
            });
        }

        function createSpaceship() {
            spaceship = new THREE.Group();
            scene.add(spaceship);
            spaceship.visible = false;
            const bodyGeometry = new THREE.ConeGeometry(2, 8, 8);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0xAAAAAA, emissive: 0x111111 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.rotation.x = Math.PI / 2;
            spaceship.add(body);
            const cockpitGeometry = new THREE.SphereGeometry(1.5, 16, 16);
            const cockpitMaterial = new THREE.MeshPhongMaterial({ color: 0x00BFFF, emissive: 0x0000FF, shininess: 50 });
            const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
            cockpit.position.z = 4;
            spaceship.add(cockpit);
            const thrusterGeometry = new THREE.CylinderGeometry(0.5, 0.8, 2, 8);
            const thrusterMaterial = new THREE.MeshPhongMaterial({ color: 0xFF0000, emissive: 0x880000 });
            const thruster1 = new THREE.Mesh(thrusterGeometry, thrusterMaterial);
            thruster1.position.set(-1.5, 0, -5);
            thruster1.rotation.x = Math.PI / 2;
            spaceship.add(thruster1);
            const thruster2 = new THREE.Mesh(thrusterGeometry, thrusterMaterial);
            thruster2.position.set(1.5, 0, -5);
            thruster2.rotation.x = Math.PI / 2;
            spaceship.add(thruster2);
            const thrusterGlowGeometry = new THREE.SphereGeometry(0.8, 16, 16);
            const thrusterGlowMaterial = new THREE.MeshBasicMaterial({ color: 0xFF4500, transparent: true, opacity: 0, blending: THREE.AdditiveBlending });
            const thrusterGlow1 = new THREE.Mesh(thrusterGlowGeometry, thrusterGlowMaterial);
            thrusterGlow1.position.set(-1.5, 0, -6);
            spaceship.add(thrusterGlow1);
            const thrusterGlow2 = new THREE.Mesh(thrusterGlowGeometry, thrusterGlowMaterial);
            thrusterGlow2.position.set(1.5, 0, -6);
            spaceship.add(thrusterGlow2);
            spaceship.thrusterGlows = [thrusterGlow1, thrusterGlow2];
            spaceship.position.set(0, 0, 50);
        }

        function toggleSpaceshipMode() {
            if (cameraMode === 'orbit') {
                cameraMode = 'spaceship';
                spaceship.visible = true;
                spaceship.position.copy(camera.position);
                spaceship.lookAt(currentCameraTarget.getWorldPosition(tempVector));
                orbitRadius = camera.position.distanceTo(currentCameraTarget.getWorldPosition(tempVector));
                const sphericalCoords = cartesianToSpherical(
                    camera.position.x - currentCameraTarget.getWorldPosition(tempVector).x,
                    camera.position.y - currentCameraTarget.getWorldPosition(tempVector).y,
                    camera.position.z - currentCameraTarget.getWorldPosition(tempVector).z
                );
                orbitTheta = sphericalCoords.theta;
                orbitPhi = sphericalCoords.phi;
            } else {
                cameraMode = 'orbit';
                spaceship.visible = false;
                currentCameraTarget = star;
                isAnimatingCamera = true;
                const starWorldPosition = star.getWorldPosition(tempVector);
                const relativeCameraPos = camera.position.clone().sub(starWorldPosition);
                const sphericalCoords = cartesianToSpherical(relativeCameraPos.x, relativeCameraPos.y, relativeCameraPos.z);
                targetOrbitRadius = sphericalCoords.radius;
                targetOrbitTheta = sphericalCoords.theta;
                targetOrbitPhi = sphericalCoords.phi;
            }
            updateFocusReleaseButtonVisibility();
        }

        function createStaticGravityGrid() {
            const { GRID_SIZE, GRID_SPACING, STATIC_GRID_RENDER_INTERVAL, STATIC_PARTICLE_SIZE, STATIC_PARTICLE_OPACITY, STATIC_PARTICLE_COLOR } = Config.GRAVITY_FIELD;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            for (let x = -GRID_SIZE / 2; x <= GRID_SIZE / 2; x += STATIC_GRID_RENDER_INTERVAL) {
                for (let y = -GRID_SIZE / 2; y <= GRID_SIZE / 2; y += STATIC_GRID_RENDER_INTERVAL) {
                    for (let z = -GRID_SIZE / 2; z <= GRID_SIZE / 2; z += STATIC_GRID_RENDER_INTERVAL) {
                        positions.push(x, y, z);
                        staticGridPositions.push(new THREE.Vector3(x, y, z));
                    }
                }
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({
                color: STATIC_PARTICLE_COLOR,
                size: STATIC_PARTICLE_SIZE,
                transparent: true,
                opacity: STATIC_PARTICLE_OPACITY,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            staticGridParticles = new THREE.Points(geometry, material);
            staticGridParticles.visible = gravityFieldVisible;
            scene.add(staticGridParticles);
        }

        function createFallingGravityParticles() {
            const { FALLING_PARTICLE_COUNT, FALLING_PARTICLE_SIZE, FALLING_PARTICLE_OPACITY, FALLING_PARTICLE_COLOR_START, FALLING_PARTICLE_MIN_LIFETIME, FALLING_PARTICLE_MAX_LIFETIME } = Config.GRAVITY_FIELD;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            if (staticGridPositions.length === 0) {
                for (let i = 0; i < FALLING_PARTICLE_COUNT; i++) {
                    const x = (Math.random() * Config.GRAVITY_FIELD.GRID_SIZE) - Config.GRAVITY_FIELD.GRID_SIZE / 2;
                    const y = (Math.random() * Config.GRAVITY_FIELD.GRID_SIZE) - Config.GRAVITY_FIELD.GRID_SIZE / 2;
                    const z = (Math.random() * Config.GRAVITY_FIELD.GRID_SIZE) - Config.GRAVITY_FIELD.GRID_SIZE / 2;
                    positions.push(x, y, z);
                    colors.push(colorStart.r, colorStart.g, colorStart.b);
                    fallingParticlesData.push({
                        position: new THREE.Vector3(x, y, z),
                        velocity: new THREE.Vector3(),
                        originalGridPointIndex: -1,
                        age: Math.random() * FALLING_PARTICLE_MAX_LIFETIME,
                        maxAge: Math.random() * (FALLING_PARTICLE_MAX_LIFETIME - FALLING_PARTICLE_MIN_LIFETIME) + FALLING_PARTICLE_MIN_LIFETIME
                    });
                }
            } else {
                for (let i = 0; i < FALLING_PARTICLE_COUNT; i++) {
                    const randomGridIndex = Math.floor(Math.random() * staticGridPositions.length);
                    const initialPos = staticGridPositions[randomGridIndex];
                    positions.push(initialPos.x, initialPos.y, initialPos.z);
                    colors.push(colorStart.r, colorStart.g, colorStart.b);
                    fallingParticlesData.push({
                        position: initialPos.clone(),
                        velocity: new THREE.Vector3(),
                        originalGridPointIndex: randomGridIndex,
                        age: Math.random() * FALLING_PARTICLE_MAX_LIFETIME,
                        maxAge: Math.random() * (FALLING_PARTICLE_MAX_LIFETIME - FALLING_PARTICLE_MIN_LIFETIME) + FALLING_PARTICLE_MIN_LIFETIME
                    });
                }
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            const material = new THREE.PointsMaterial({
                size: FALLING_PARTICLE_SIZE,
                vertexColors: true,
                transparent: true,
                opacity: FALLING_PARTICLE_OPACITY,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            fallingGravityParticles = new THREE.Points(geometry, material);
            fallingGravityParticles.visible = gravityFieldVisible;
            scene.add(fallingGravityParticles);
        }

        function updateGravitySimulation() {
            if (!gravityFieldVisible || !fallingGravityParticles) return;
            const positionsArray = fallingGravityParticles.geometry.attributes.position.array;
            const colorsArray = fallingGravityParticles.geometry.attributes.color.array;
            const { GRAVITY_STRENGTH, VELOCITY_DECAY, RESET_THRESHOLD_RADIUS_MULTIPLIER, MAX_PARTICLE_DISPLACEMENT, COLOR_CHANGE_DISTANCE_FACTOR } = Config.GRAVITY_FIELD;
            const celestialBodies = [
                { mesh: star, visualMass: Config.STAR.VISUAL_MASS, radius: Config.STAR.RADIUS }
            ].concat(planets.map(p => ({
                mesh: p.mesh, visualMass: p.visualMass, radius: p.mesh.children[0].geometry.parameters.radius
            })));
            for (let i = 0; i < fallingParticlesData.length; i++) {
                const particle = fallingParticlesData[i];
                let totalForce = new THREE.Vector3();
                let closestDistance = Infinity;
                celestialBodies.forEach(body => {
                    const bodyWorldPos = body.mesh.getWorldPosition(tempVector);
                    const direction = bodyWorldPos.clone().sub(particle.position);
                    let distance = direction.length();
                    if (distance < closestDistance) {
                        closestDistance = distance;
                    }
                    const minDistance = body.radius * 0.5;
                    if (distance < minDistance) {
                        distance = minDistance;
                    }
                    const forceMagnitude = (GRAVITY_STRENGTH * body.visualMass) / (distance * distance);
                    tempForce.copy(direction).normalize().multiplyScalar(forceMagnitude);
                    totalForce.add(tempForce);
                    if (distance < body.radius * RESET_THRESHOLD_RADIUS_MULTIPLIER) {
                        resetFallingParticle(i);
                        return;
                    }
                });
                particle.velocity.add(totalForce);
                particle.velocity.multiplyScalar(VELOCITY_DECAY);
                particle.position.add(particle.velocity);
                particle.age++;
                if (particle.age > particle.maxAge || (particle.originalGridPointIndex !== -1 && particle.position.distanceTo(staticGridPositions[particle.originalGridPointIndex]) > MAX_PARTICLE_DISPLACEMENT)) {
                    resetFallingParticle(i);
                }
                positionsArray[i * 3] = particle.position.x;
                positionsArray[i * 3 + 1] = particle.position.y;
                positionsArray[i * 3 + 2] = particle.position.z;
                const normalizedDistance = Math.min(1, closestDistance / COLOR_CHANGE_DISTANCE_FACTOR);
                tempColor.copy(colorStart).lerp(colorEnd, 1 - normalizedDistance);
                colorsArray[i * 3] = tempColor.r;
                colorsArray[i * 3 + 1] = tempColor.g;
                colorsArray[i * 3 + 2] = tempColor.b;
            }
            fallingGravityParticles.geometry.attributes.position.needsUpdate = true;
            fallingGravityParticles.geometry.attributes.color.needsUpdate = true;
            if (gravityFadeOpacity < 1 && gravityFieldVisible) {
                gravityFadeOpacity = Math.min(1, gravityFadeOpacity + 0.016 / (Config.GRAVITY_FIELD.FADE_DURATION / 1000));
                staticGridParticles.material.opacity = Config.GRAVITY_FIELD.STATIC_PARTICLE_OPACITY * gravityFadeOpacity;
                fallingGravityParticles.material.opacity = Config.GRAVITY_FIELD.FALLING_PARTICLE_OPACITY * gravityFadeOpacity;
            } else if (gravityFadeOpacity > 0 && !gravityFieldVisible) {
                gravityFadeOpacity = Math.max(0, gravityFadeOpacity - 0.016 / (Config.GRAVITY_FIELD.FADE_DURATION / 1000));
                staticGridParticles.material.opacity = Config.GRAVITY_FIELD.STATIC_PARTICLE_OPACITY * gravityFadeOpacity;
                fallingGravityParticles.material.opacity = Config.GRAVITY_FIELD.FALLING_PARTICLE_OPACITY * gravityFadeOpacity;
            }
        }

        function resetFallingParticle(index) {
            const { FALLING_PARTICLE_MIN_LIFETIME, FALLING_PARTICLE_MAX_LIFETIME } = Config.GRAVITY_FIELD;
            if (staticGridPositions.length > 0) {
                const randomGridIndex = Math.floor(Math.random() * staticGridPositions.length);
                const newPos = staticGridPositions[randomGridIndex];
                fallingParticlesData[index].position.copy(newPos);
                fallingParticlesData[index].originalGridPointIndex = randomGridIndex;
            } else {
                const { GRID_SIZE } = Config.GRAVITY_FIELD;
                const halfGrid = GRID_SIZE / 2;
                const x = (Math.random() * GRID_SIZE) - halfGrid;
                const y = (Math.random() * GRID_SIZE) - halfGrid;
                const z = (Math.random() * GRID_SIZE) - halfGrid;
                fallingParticlesData[index].position.set(x, y, z);
                fallingParticlesData[index].originalGridPointIndex = -1;
            }
            fallingParticlesData[index].velocity.set(0, 0, 0);
            fallingParticlesData[index].age = 0;
            fallingParticlesData[index].maxAge = Math.random() * (FALLING_PARTICLE_MAX_LIFETIME - FALLING_PARTICLE_MIN_LIFETIME) + FALLING_PARTICLE_MIN_LIFETIME;
        }

        function toggleGravityField() {
            gravityFieldVisible = !gravityFieldVisible;
            staticGridParticles.visible = gravityFadeOpacity > 0 || gravityFieldVisible;
            fallingGravityParticles.visible = gravityFadeOpacity > 0 || gravityFieldVisible;
        }

        function togglePause() {
            isPaused = !isPaused;
            togglePauseButton.textContent = isPaused ? '‚ñ∂Ô∏è' : '‚èØÔ∏è';
        }

        function updateInfoPanel() {
            if (currentCameraTarget === star) {
                infoPanel.style.display = 'none';
            } else {
                const planetData = planets.find(p => p.mesh === currentCameraTarget);
                if (planetData) {
                    const planetConfig = Config.PLANETS.find(p => p.name === planetData.name);
                    infoPanel.innerHTML = `
                        <b>${planetData.name}</b><br>
                        Radius: ${planetConfig.radius} units<br>
                        Orbit: ${planetConfig.orbit} units<br>
                        Mass: ${planetConfig.visualMass} units
                    `;
                    infoPanel.style.display = 'block';
                }
            }
        }

        function onDocumentKeyDown(event) {
            const key = event.key.toLowerCase();
            if (key === 'h') {
                toggleHelpOverlay();
                return;
            }
            if (cameraMode === 'spaceship') {
                if (key === 'w') keyboardState.w = true;
                if (key === 's') keyboardState.s = true;
                if (key === 'a') keyboardState.a = true;
                if (key === 'd') keyboardState.d = true;
            } else {
                if (key === '0') {
                    if (currentCameraTarget !== star) {
                        focusCameraOn(star);
                    }
                } else if (key >= '1' && key <= '9') {
                    const planetIndex = parseInt(key) - 1;
                    if (planetIndex >= 0 && planetIndex < planets.length) {
                        const targetPlanet = planets[planetIndex].mesh;
                        if (currentCameraTarget !== targetPlanet) {
                            focusCameraOn(targetPlanet);
                        }
                    } else {
                        showMessageBox(`Planet ${key} does not exist in this system.`);
                    }
                }
            }
        }

        function onDocumentKeyUp(event) {
            const key = event.key.toLowerCase();
            if (cameraMode === 'spaceship') {
                if (key === 'w') keyboardState.w = false;
                if (key === 's') keyboardState.s = false;
                if (key === 'a') keyboardState.a = false;
                if (key === 'd') keyboardState.d = false;
            }
        }

        function onDocumentMouseDown(event) {
            event.preventDefault();
            if (cameraMode === 'orbit') {
                isDragging = true;
                previousMouseX = event.clientX;
                previousMouseY = event.clientY;
                isAnimatingCamera = false;
            } else if (cameraMode === 'spaceship') {
                isSteering = true;
                document.body.style.cursor = 'grabbing';
            }
        }

        function onDocumentMouseUp(event) {
            event.preventDefault();
            isDragging = false;
            if (cameraMode === 'spaceship') {
                document.body.style.cursor = 'default';
            }
        }

        function onDocumentMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            if (cameraMode === 'orbit') {
                raycaster.setFromCamera(mouse, camera);
                const intersectableMeshes = planets.map(p => p.mesh.children[0]);
                const intersects = raycaster.intersectObjects(intersectableMeshes);
                if (intersects.length > 0) {
                    const newHoveredPlanet = intersects[0].object.parent;
                    if (hoveredPlanet !== newHoveredPlanet) {
                        if (hoveredPlanet) {
                            hoveredPlanet.children[0].material.emissive.setHex(hoveredPlanet.userData.originalEmissiveColor);
                        }
                        hoveredPlanet = newHoveredPlanet;
                        hoveredPlanet.children[0].material.emissive.setHex(0x00FF00);
                    }
                } else {
                    if (hoveredPlanet) {
                        hoveredPlanet.children[0].material.emissive.setHex(hoveredPlanet.userData.originalEmissiveColor);
                        hoveredPlanet = null;
                    }
                }
            }
            if (isDragging && cameraMode === 'orbit') {
                const deltaX = event.clientX - previousMouseX;
                const deltaY = event.clientY - previousMouseY;
                orbitTheta += -deltaX * Config.CAMERA.ORBIT_ROTATION_SPEED;
                orbitPhi += deltaY * Config.CAMERA.ORBIT_ROTATION_SPEED;
                orbitPhi = Math.max(0.01, Math.min(Math.PI - 0.01, orbitPhi));
                previousMouseX = event.clientX;
                previousMouseY = event.clientY;
            } else if (isSteering && cameraMode === 'spaceship') {
                const deltaX = event.movementX || 0;
                const deltaY = event.movementY || 0;
                mouseLookX += deltaX * Config.SPACESHIP.ROTATION_SPEED;
                mouseLookY += deltaY * Config.SPACESHIP.ROTATION_SPEED;
                mouseLookY = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mouseLookY));
            }
        }

        function onDocumentMouseWheel(event) {
            event.preventDefault();
            if (cameraMode === 'orbit') {
                isAnimatingCamera = false;
                let minZoom = Config.CAMERA.ORBIT_RADIUS_MIN;
                let maxZoom = Config.CAMERA.ORBIT_RADIUS_MAX;
                if (currentCameraTarget !== star) {
                    const planetData = planets.find(p => p.mesh === currentCameraTarget);
                    if (planetData) {
                        minZoom = planetData.mesh.children[0].geometry.parameters.radius * 1.5;
                        maxZoom = planetData.mesh.children[0].geometry.parameters.radius * 20;
                    }
                }
                orbitRadius += event.deltaY * Config.CAMERA.ORBIT_ZOOM_SPEED;
                orbitRadius = Math.max(minZoom, Math.min(maxZoom, orbitRadius));
                targetOrbitRadius = orbitRadius;
            }
        }

        function onDocumentClick(event) {
            if (cameraMode === 'orbit') {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersectableMeshes = planets.map(p => p.mesh.children[0]);
                const intersects = raycaster.intersectObjects(intersectableMeshes);
                if (intersects.length > 0) {
                    const clickedObject = intersects[0].object.parent;
                    const foundPlanet = planets.find(p => p.mesh === clickedObject);
                    if (foundPlanet && currentCameraTarget !== foundPlanet.mesh) {
                        focusCameraOn(foundPlanet.mesh);
                    }
                }
            }
        }

        function onTouchStart(event) {
            if (event.touches.length === 1 && cameraMode === 'orbit') {
                touchStartX = event.touches[0].clientX;
                touchStartY = event.touches[0].clientY;
                isDragging = true;
                isAnimatingCamera = false;
            }
        }

        function onTouchMove(event) {
            if (isDragging && cameraMode === 'orbit' && event.touches.length === 1) {
                event.preventDefault();
                const touchX = event.touches[0].clientX;
                const touchY = event.touches[0].clientY;
                const deltaX = touchX - touchStartX;
                const deltaY = touchY - touchStartY;
                orbitTheta += -deltaX * Config.CAMERA.ORBIT_ROTATION_SPEED * 0.5;
                orbitPhi += deltaY * Config.CAMERA.ORBIT_ROTATION_SPEED * 0.5;
                orbitPhi = Math.max(0.01, Math.min(Math.PI - 0.01, orbitPhi));
                touchStartX = touchX;
                touchStartY = touchY;
            }
        }

        function onTouchEnd() {
            isDragging = false;
        }

        function onFocusReleaseButtonClick() {
            if (currentCameraTarget !== star) {
                focusCameraOn(star);
            }
        }

        function updateFocusReleaseButtonVisibility() {
            focusReleaseButton.style.display = (cameraMode === 'orbit' && currentCameraTarget !== star) ? 'flex' : 'none';
        }

        function createPlanetButtonIcon(planetData, buttonElement) {
            const iconScene = new THREE.Scene();
            const iconCamera = new THREE.PerspectiveCamera(75, 1, 0.1, 100);
            iconCamera.position.z = planetData.mesh.children[0].geometry.parameters.radius * 2.5;
            iconCamera.lookAt(0, 0, 0);
            const iconLight = new THREE.PointLight(0xFFFFFF, 1.0);
            iconLight.position.set(5, 5, 5);
            iconScene.add(iconLight);
            iconScene.add(new THREE.AmbientLight(0x404040, 0.5));
            const clonedPlanet = planetData.mesh.clone();
            clonedPlanet.position.set(0, 0, 0);
            if (planetData.name === "Saturn" || planetData.name === "Neptune") {
                clonedPlanet.rotation.x = Math.PI / 6;
            }
            iconScene.add(clonedPlanet);
            const planetConfig = Config.PLANETS.find(p => p.name === planetData.name);
            if (planetConfig && planetConfig.rings) {
                const ringGeometry = new THREE.RingGeometry(planetConfig.rings.innerRadius, planetConfig.rings.outerRadius, 64);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: planetConfig.rings.color,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: planetConfig.rings.opacity,
                });
                const clonedRings = new THREE.Mesh(ringGeometry, ringMaterial);
                clonedRings.position.set(0, 0, 0);
                clonedRings.rotation.x = Math.PI / 2;
                iconScene.add(clonedRings);
            }
            const iconRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            iconRenderer.setSize(Config.UI.BUTTON_ICON_SIZE, Config.UI.BUTTON_ICON_SIZE);
            iconRenderer.setClearColor(0x000000, 0);
            iconRenderer.render(iconScene, iconCamera);
            buttonElement.style.backgroundImage = `url(${iconRenderer.domElement.toDataURL()})`;
            iconRenderer.domElement.remove();
            iconRenderer.forceContextLoss();
            iconScene.traverse(object => {
                if (object.geometry) object.geometry.dispose();
                if (object.material) {
                    if (Array.isArray(object.material)) {
                        object.material.forEach(mat => mat.dispose());
                    } else {
                        object.material.dispose();
                    }
                }
            });
            iconScene.clear();
        }

        async function setupCelestialBodies() {
            createSun();
            for (const pConfig of Config.PLANETS) {
                const planetData = createPlanet(pConfig);
                if (pConfig.lightsTexture) {
                    addEarthLights(planetData.mesh, pConfig.radius, pConfig.lightsTexture);
                }
                if (pConfig.moons) {
                    pConfig.moons.forEach(moonConfig => createMoon(planetData.mesh, moonConfig));
                }
                if (pConfig.rings) {
                    createRing(planetData.mesh, pConfig.rings);
                }
                if (pConfig.fieldLines) {
                    createMagneticFieldLines(planetData.mesh, pConfig.radius, pConfig.fieldLines.numLines, pConfig.fieldLines.extent, pConfig.fieldLines.color);
                }
            }
            createMagneticFieldLines(star, Config.STAR.RADIUS, Config.STAR.FIELD_LINES.NUM_LINES, Config.STAR.FIELD_LINES.EXTENT_EQUATORIAL, Config.STAR.FIELD_LINES.COLOR);
            createAsteroidBelt();
            createStars();
            createOrganicNebula();
            createSpaceship();
            createStaticGravityGrid();
            createFallingGravityParticles();
            const planetButtonIds = Array.from({ length: Config.PLANETS.length }, (_, i) => `planetButton${i}`);
            await Promise.all(planets.map(planetData => new Promise(resolve => {
                if (planetData.mesh.children[0].material.map && !planetData.mesh.children[0].material.map.image) {
                    planetData.mesh.children[0].material.map.onUpdate = () => resolve();
                } else {
                    resolve();
                }
            })));
            planets.forEach((planetData, index) => {
                const button = document.getElementById(planetButtonIds[index]);
                if (button) {
                    button.style.setProperty('--button-index', index + Config.UI.PLANET_BUTTON_START_INDEX);
                    button.title = `Focus on ${planetData.name}`;
                    createPlanetButtonIcon(planetData, button);
                    button.addEventListener('click', () => focusCameraOn(planetData.mesh));
                }
            });
            const systemButton = document.getElementById('planetButtonSystem');
            if (systemButton) {
                systemButton.style.setProperty('--button-index', Config.PLANETS.length + Config.UI.PLANET_BUTTON_START_INDEX);
                systemButton.title = "Focus on Sun";
                const sunIconScene = new THREE.Scene();
                const sunIconCamera = new THREE.PerspectiveCamera(75, 1, 0.1, 100);
                sunIconCamera.position.z = 10;
                const sunIconMesh = new THREE.Mesh(new THREE.SphereGeometry(3, 16, 16), new THREE.MeshBasicMaterial({ color: 0xFFFF00 }));
                sunIconScene.add(sunIconMesh);
                const sunIconRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                sunIconRenderer.setSize(Config.UI.BUTTON_ICON_SIZE, Config.UI.BUTTON_ICON_SIZE);
                sunIconRenderer.setClearColor(0x000000, 0);
                sunIconRenderer.render(sunIconScene, sunIconCamera);
                systemButton.style.backgroundImage = `url(${sunIconRenderer.domElement.toDataURL()})`;
                systemButton.addEventListener('click', () => focusCameraOn(star));
                sunIconRenderer.domElement.remove();
                sunIconRenderer.forceContextLoss();
                sunIconScene.traverse(object => {
                    if (object.geometry) object.geometry.dispose();
                    if (object.material) object.material.dispose();
                });
                sunIconScene.clear();
            }
        }

        function setupEventListeners() {
            document.addEventListener('mousedown', onDocumentMouseDown, false);
            document.addEventListener('mouseup', onDocumentMouseUp, false);
            document.addEventListener('mousemove', onDocumentMouseMove, false);
            document.addEventListener('wheel', onDocumentMouseWheel, false);
            document.addEventListener('click', onDocumentClick, false);
            document.addEventListener('keydown', onDocumentKeyDown, false);
            document.addEventListener('keyup', onDocumentKeyUp, false);
            document.addEventListener('touchstart', onTouchStart, false);
            document.addEventListener('touchmove', onTouchMove, false);
            document.addEventListener('touchend', onTouchEnd, false);
            focusReleaseButton.addEventListener('click', onFocusReleaseButtonClick, false);
            toggleFieldLinesButton.addEventListener('click', toggleMagneticFieldLines, false);
            toggleSpaceshipButton.addEventListener('click', toggleSpaceshipMode, false);
            toggleGravityFieldButton.addEventListener('click', toggleGravityField, false);
            togglePauseButton.addEventListener('click', togglePause, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function focusCameraOn(newTarget) {
            if (cameraMode === 'spaceship') {
                toggleSpaceshipMode();
                setTimeout(() => {
                    if (newTarget !== star) {
                        focusCameraOn(newTarget);
                    }
                }, 500);
                return;
            }
            currentCameraTarget = newTarget;
            isAnimatingCamera = true;
            updateFocusReleaseButtonVisibility();
            updateInfoPanel();
            if (newTarget === star) {
                targetOrbitRadius = Config.CAMERA.ORBIT_RADIUS_DEFAULT;
            } else {
                const focusedPlanetData = planets.find(p => p.mesh === newTarget);
                if (focusedPlanetData) {
                    targetOrbitRadius = focusedPlanetData.mesh.children[0].geometry.parameters.radius * Config.CAMERA.PLANET_ZOOM_MULTIPLIER;
                    targetOrbitRadius = Math.max(Config.CAMERA.ORBIT_RADIUS_MIN, Math.min(Config.CAMERA.ORBIT_RADIUS_MAX, targetOrbitRadius));
                }
            }
            const targetWorldPosition = newTarget.getWorldPosition(tempVector);
            const relativeCameraPos = camera.position.clone().sub(targetWorldPosition);
            const sphericalCoords = cartesianToSpherical(relativeCameraPos.x, relativeCameraPos.y, relativeCameraPos.z);
            targetOrbitTheta = sphericalCoords.theta;
            targetOrbitPhi = sphericalCoords.phi;
            orbitTheta = THREE.MathUtils.euclideanModulo(orbitTheta, Math.PI * 2);
            targetOrbitTheta = THREE.MathUtils.euclideanModulo(targetOrbitTheta, Math.PI * 2);
            if (Math.abs(targetOrbitTheta - orbitTheta) > Math.PI) {
                if (targetOrbitTheta > orbitTheta) {
                    orbitTheta += Math.PI * 2;
                } else {
                    orbitTheta -= Math.PI * 2;
                }
            }
        }

        function updateCameraPosition() {
            if (cameraMode === 'orbit') {
                if (isAnimatingCamera) {
                    orbitRadius = THREE.MathUtils.lerp(orbitRadius, targetOrbitRadius, Config.CAMERA.ANIMATION_LERP_FACTOR);
                    orbitTheta = THREE.MathUtils.lerp(orbitTheta, targetOrbitTheta, Config.CAMERA.ANIMATION_LERP_FACTOR);
                    orbitPhi = THREE.MathUtils.lerp(orbitPhi, targetOrbitPhi, Config.CAMERA.ANIMATION_LERP_FACTOR);
                    if (Math.abs(orbitRadius - targetOrbitRadius) < Config.CAMERA.ANIMATION_THRESHOLD_RADIUS &&
                        Math.abs(orbitTheta - targetOrbitTheta) < Config.CAMERA.ANIMATION_THRESHOLD_ANGLE &&
                        Math.abs(orbitPhi - targetOrbitPhi) < Config.CAMERA.ANIMATION_THRESHOLD_ANGLE) {
                        isAnimatingCamera = false;
                    }
                }
                orbitPhi = Math.max(0.01, Math.min(Math.PI - 0.01, orbitPhi));
                const targetWorldPosition = currentCameraTarget.getWorldPosition(tempVector);
                camera.position.x = targetWorldPosition.x + orbitRadius * Math.sin(orbitPhi) * Math.sin(orbitTheta);
                camera.position.y = targetWorldPosition.y + orbitRadius * Math.cos(orbitPhi);
                camera.position.z = targetWorldPosition.z + orbitRadius * Math.sin(orbitPhi) * Math.cos(orbitTheta);
                camera.lookAt(targetWorldPosition);
            } else if (cameraMode === 'spaceship') {
                spaceship.rotation.y -= mouseLookX;
                spaceship.rotation.x -= mouseLookY;
                mouseLookX = 0;
                mouseLookY = 0;
                const forwardVector = new THREE.Vector3(0, 0, 1).applyQuaternion(spaceship.quaternion);
                const rightVector = new THREE.Vector3(1, 0, 0).applyQuaternion(spaceship.quaternion);
                let isMoving = false;
                if (keyboardState.w) {
                    spaceship.position.add(forwardVector.multiplyScalar(Config.SPACESHIP.SPEED));
                    isMoving = true;
                }
                if (keyboardState.s) {
                    spaceship.position.sub(forwardVector.multiplyScalar(Config.SPACESHIP.SPEED));
                    isMoving = true;
                }
                if (keyboardState.a) {
                    spaceship.position.sub(rightVector.multiplyScalar(Config.SPACESHIP.SPEED));
                    isMoving = true;
                }
                if (keyboardState.d) {
                    spaceship.position.add(rightVector.multiplyScalar(Config.SPACESHIP.SPEED));
                    isMoving = true;
                }
                spaceship.thrusterGlows.forEach(glow => {
                    glow.material.opacity = isMoving ? 0.5 : 0;
                });
                const cameraWorldPosition = Config.SPACESHIP.CAMERA_OFFSET.clone().applyQuaternion(spaceship.quaternion).add(spaceship.position);
                camera.position.copy(cameraWorldPosition);
                camera.lookAt(spaceship.position);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            if (!isPaused) {
                planets.forEach(planet => {
                    planet.orbitPivot.rotation.y += planet.orbitSpeed;
                    planet.mesh.rotation.y += planet.rotationSpeed;
                });
                moons.forEach(moon => {
                    moon.orbitPivot.rotation.y += moon.orbitSpeed;
                    moon.mesh.rotation.y += moon.rotationSpeed;
                });
                if (asteroids.instancedMesh) {
                    const matrix = new THREE.Matrix4();
                    asteroids.forEach(asteroid => {
                        asteroid.angle += asteroid.orbitSpeed;
                        matrix.setPosition(
                            asteroid.orbitRadius * Math.cos(asteroid.angle),
                            asteroid.mesh ? asteroid.mesh.position.y : (Math.random() - 0.5) * 2,
                            asteroid.orbitRadius * Math.sin(asteroid.angle)
                        );
                        asteroids.instancedMesh.setMatrixAt(asteroid.index, matrix);
                    });
                    asteroids.instancedMesh.instanceMatrix.needsUpdate = true;
                }
                if (nebulaGroup) {
                    nebulaGroup.rotation.y += Config.NEBULA.ROTATION_SPEED_Y;
                    nebulaGroup.rotation.x += Config.NEBULA.ROTATION_SPEED_X;
                }
                star.rotation.y += Config.STAR.ROTATION_SPEED;
            }
            updateCameraPosition();
            updateGravitySimulation();
            renderer.render(scene, camera);
        }

        window.onload = function () {
            setupScene();
            setupCelestialBodies();
            setupEventListeners();
            updateCameraPosition();
            animate();
        };
    </script>
</body>
</html>
